---
title: "Fortran-Programming"
author: "Janesh Devkota"
date: "March 2, 2017"
output: 
  bookdown::gitbook
---


```{r function-gitbook, eval=FALSE}
bookdown::render_book("index.Rmd", "bookdown::gitbook")
```

# Introduction 

Welcome to I don't know Fortran Series. This notebook is generated by my daily use in Fortran for past several years. Sometimes 
we are stuck in simple things in Fortran. This book gives a guide on using basic things / functions in Fortran. 

# Logical operators 

There are 5 logical operators in Fortran. They are: 

1. `.NOT.`
2. `.OR.`
3. `.AND.`
4. `.EQV.`
5. `.NEQV.`

`.NOT.` is the highest  `.OR.` and `.AND.`, `.EQV.` and `.NEQV.` are the lowest.

# If structure

```
IF (logical-expression-1) THEN
statement sequence 1
ELSE IF (logical-expression-2) THEN
statement seqence 2
ELSE IF (logical-expression-3) THEN
statement sequence statement sequence 3
ELSE IF (.....) THEN
...........
ELSE
10 statement sequence ELSE END IF 
```

# Select Case 

![Select Case](https://snag.gy/03Xijy.jpg)


# Debugging Tips

Source: https://software.intel.com/en-us/articles/tips-for-debugging-run-time-failures-in-intel-fortran-applications
Tips for Debugging Run-time Failures in Applications Built with the Intel® Fortran Compiler
Your app builds successfully, but crashes at runtime. What Next? Try some useful Intel compiler diagnostic options before launching into lengthy debugger sessions.

1) Build with /traceback (Windows*) or –traceback (Linux* or Mac OS* X).
This can give a stack trace with subroutine or function names, source filenames and line numbers at the point of failure, if it is in user code, without the need to build with debug symbols. This is designed as a lightweight option that can also be left enabled for release builds. If an end user encounters a problem, the traceback can be a starting point for a bug report.

2) Build with /gen-interfaces /warn:interfaces (Windows) or –gen-interfaces –warn interfaces (Linux or Mac OS X). This is able to detect at compile time many instances of argument mismatches between caller and callee, which can otherwise lead to hard-to-debug runtime failures. These options automatically create and check explicit, Fortran90 style interfaces for Fortran77 style or other code that does not already have them. There is no impact on run-time performance.

3) Try building and running with /check (Windows) or –check (Linux and Mac OS X).
This instruments your code and makes a number of valuable run-time checks, including array bounds checking, checking for uninitialized or disassociated pointers, and for some types of uninitialized local scalar variables. Bounds checking in particular is likely to make your program run slower.

4) Build your program, including the main routine, with /fpe:0 (Windows) or –fpe0 (Linux or Mac OS X). This will cause your program to halt if it encounters a divide-by-zero, overflow or invalid floating-point exception, instead of generating a NaN (not-a-number) and silently continuing. If you have also specified /traceback (-traceback), you should be able to see where the floating point exception occurred. Any impact on performance is likely to be small.

5) If your application fails early on with a segmentation fault, you might be exceeding the default maximum stack size. On Linux or Mac OS X, try setting
ulimit –s unlimited (bash) or limit stacksize unlimited (C shell)
On Windows, use the /F build option or increase the stack limits in the IDE under project properties/linker/system/ Stack Commit Size and Stack Reserve Size.

6) Use the compiler provided interfaces. If you call run-time library functions, build with
      USE IFLPORT
If you call OpenMP run-time library functions, compile with
      USE OMP_LIB
If you call functions from MKL or IMSL*, USE the corresponding module(s).

7) Look carefully for any error messages in your output log file. Errors from the Fortran run-time library include an error number. Additional information about such RTL errors may be found in the main compiler documentation under “List of Run-Time Error Messages”, or by searching for the error number directly.

8) If you are building an application using OpenMP*, check out the advice under “Tips for Debugging OpenMP Apps” at /en-us/articles/threading-fortran-applications-for-parallel-performance-on-multi-core-systems  

All the above options may be used with release (optimized) builds. Certain options are enabled by default in a debug build made through the Microsoft* Visual Studio* IDE on Windows.

Additional information may be found in the main compiler documentation in the section Building Applications / Error Handling / Handling Run-Time Errors, e.g. “Understanding Run-Time Errors” and the references therein;  also in the article  /en-us/articles/determining-root-cause-of-segmentation-faults-sigsegv-or-sigbus-errors.


9) OK, sometimes you need to do the heavy lifting. If these suggestions haven’t helped, or if they helped localize the problem but you need more information, it may be time to start interactive debugging. For Windows, see the section Building Applications / Debugging in the main compiler documentation. For Linux or Mac OS X, see the documentation for the Intel® Debugger (idb).

## Debugging shortcuts

* CTRL + `-` : To go back and forth to the last used. 
* `F12` : Go to Definition


# Snippets

## Check if a file exists

```

! DEFINE FEXISTS as LOGICAL
LOGICAL FEXISTS 
INQUIRE (FILE = 'Filename.DAT', EXIST = FEXISTS)
  IF( FEXISTS )THEN

  ELSE

  ENDIF
```

## Open and close files

To open files in FORTRAN simply use:

`OPEN(7, FILE = 'hello.txt', STATUS = 'UNKNOWN')`
where 7 = the unique number assigned to the file that is being opened.

To close the files we can simply use :

`CLOSE(7)`

If we want to delete the file then we can use 

`CLOSE(7, STATUS = 'DELETE')`

A simple example is given here:

```
open (unit=CHROMOSOME_UNIT, file=filename, status='old', &
		    iostat=open_status, action='read', position='rewind')
		if ( open_status /= 0 ) then
		    print *, 'Could not open ',filename,' for reading.', &
			'unit = ', unit
		    stop
		endif
```
The open statement uses a number of tags to specify which file to open and how it will be used.

**Required tags:**

* unit: integer unit number to be used by read, write, and close.
* filename: String constant, variable, or expression representing the absolute or relative pathname of the file.
* status: String constant, variable, or expression that reduces to:
    * 'old': For existing files, usually used when reading.
    * 'new': Used when writing to a file that does not yet exist.
    * 'replace': Used to overwrite a file that already exists.
* iostat: Integer variable to receive the status of the open operation. If the file is opened successfully, the variable is set to 0. Otherwise, it will contain a non-zero error code that indicates why the file could not be opened. (Does not exist, no permission, etc.)

**Optional tags:**

* action: String
    * 'read': Open for reading only
    * 'write': Open for writing only
    * 'readwrite': Allow both reading and writing
* position: String
    * 'rewind': Start at beginning of file
    * 'append': Writes add to file rather than overwrite


## Append files in FORTRAN

To do the appends in FORTRAN we could do something like:
```
OPEN(95,FILE=OUTDIR//'*.OUT',POSITION='APPEND',STATUS='OLD',  FORM='BINARY')
! Some code 
CLOSE(95) 
```

In the above code 95 is just used arbitrarily.

## Allocatable arrays in FORTRAN 90

In FORTRAN 90, one can assign allocatable arrays with the syntax as follows:

```
REAL,ALLOCATABLE,DIMENSION(:)::RSSBCW
REAL, ALLOCATABLE, DIMENSION(:,:):: TESTDF
```

In the above example, RSSBCW is a 1-D vector whereas TESTDF is a 2 dimensional array.


